// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: showtime_seat.get.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getAllShowtimeSeatsByShowtimeId = `-- name: GetAllShowtimeSeatsByShowtimeId :many
SELECT  
    ss.id,
    ss.showtime_id,
    ss.seat_id,
    s.seat_type,
    s.seat_number,
    s.price,
    ss.status,
    ss.booked_by,
    ss.created_at,
    ss.booked_at
FROM showtime_seats ss
JOIN seats s ON s.id = ss.seat_id
WHERE ss.showtime_id = $1
`

type GetAllShowtimeSeatsByShowtimeIdRow struct {
	ID         int32            `json:"id"`
	ShowtimeID int32            `json:"showtime_id"`
	SeatID     int32            `json:"seat_id"`
	SeatType   SeatTypes        `json:"seat_type"`
	SeatNumber string           `json:"seat_number"`
	Price      int32            `json:"price"`
	Status     SeatStatuses     `json:"status"`
	BookedBy   string           `json:"booked_by"`
	CreatedAt  pgtype.Timestamp `json:"created_at"`
	BookedAt   pgtype.Timestamp `json:"booked_at"`
}

func (q *Queries) GetAllShowtimeSeatsByShowtimeId(ctx context.Context, showtimeID int32) ([]GetAllShowtimeSeatsByShowtimeIdRow, error) {
	rows, err := q.db.Query(ctx, getAllShowtimeSeatsByShowtimeId, showtimeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllShowtimeSeatsByShowtimeIdRow{}
	for rows.Next() {
		var i GetAllShowtimeSeatsByShowtimeIdRow
		if err := rows.Scan(
			&i.ID,
			&i.ShowtimeID,
			&i.SeatID,
			&i.SeatType,
			&i.SeatNumber,
			&i.Price,
			&i.Status,
			&i.BookedBy,
			&i.CreatedAt,
			&i.BookedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllShowtimeSeatsFromEarliestTomorrow = `-- name: GetAllShowtimeSeatsFromEarliestTomorrow :many
WITH next_showtime AS (
    SELECT st.id AS showtime_id
    FROM showtimes st
    WHERE st.film_id = $1
        AND st.show_date >= CURRENT_DATE + INTERVAL '1 day'
    ORDER BY st.show_date, st.start_time
    LIMIT 1
)
SELECT 
    ss.id,
    ss.showtime_id,
    ss.seat_id,
    s.seat_type,
    s.seat_number,
    s.price,
    ss.status,
    ss.booked_by,
    ss.created_at,
    ss.booked_at
FROM showtime_seats ss
JOIN next_showtime ns ON ss.showtime_id = ns.showtime_id
JOIN seats s ON ss.seat_id = s.id
ORDER BY ss.seat_id
`

type GetAllShowtimeSeatsFromEarliestTomorrowRow struct {
	ID         int32            `json:"id"`
	ShowtimeID int32            `json:"showtime_id"`
	SeatID     int32            `json:"seat_id"`
	SeatType   SeatTypes        `json:"seat_type"`
	SeatNumber string           `json:"seat_number"`
	Price      int32            `json:"price"`
	Status     SeatStatuses     `json:"status"`
	BookedBy   string           `json:"booked_by"`
	CreatedAt  pgtype.Timestamp `json:"created_at"`
	BookedAt   pgtype.Timestamp `json:"booked_at"`
}

func (q *Queries) GetAllShowtimeSeatsFromEarliestTomorrow(ctx context.Context, filmID int32) ([]GetAllShowtimeSeatsFromEarliestTomorrowRow, error) {
	rows, err := q.db.Query(ctx, getAllShowtimeSeatsFromEarliestTomorrow, filmID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllShowtimeSeatsFromEarliestTomorrowRow{}
	for rows.Next() {
		var i GetAllShowtimeSeatsFromEarliestTomorrowRow
		if err := rows.Scan(
			&i.ID,
			&i.ShowtimeID,
			&i.SeatID,
			&i.SeatType,
			&i.SeatNumber,
			&i.Price,
			&i.Status,
			&i.BookedBy,
			&i.CreatedAt,
			&i.BookedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
